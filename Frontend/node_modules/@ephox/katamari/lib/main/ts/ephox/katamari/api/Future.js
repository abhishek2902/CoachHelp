import { LazyValue } from './LazyValue';
const errorReporter = (err) => {
    // we can not throw the error in the reporter as it will just be black-holed
    // by the Promise so we use a setTimeout to escape the Promise.
    setTimeout(() => {
        throw err;
    }, 0);
};
const make = (run) => {
    const get = (callback) => {
        run().then(callback, errorReporter);
    };
    /** map :: this Future a -> (a -> b) -> Future b */
    const map = (fab) => {
        return make(() => run().then(fab));
    };
    /** bind :: this Future a -> (a -> Future b) -> Future b */
    const bind = (aFutureB) => {
        return make(() => run().then((v) => aFutureB(v).toPromise()));
    };
    /** anonBind :: this Future a -> Future b -> Future b
     *  Returns a future, which evaluates the first future, ignores the result, then evaluates the second.
     */
    const anonBind = (futureB) => {
        return make(() => run().then(() => futureB.toPromise()));
    };
    const toLazy = () => {
        return LazyValue.nu(get);
    };
    const toCached = () => {
        let cache = null;
        return make(() => {
            if (cache === null) {
                cache = run();
            }
            return cache;
        });
    };
    const toPromise = run;
    return {
        map,
        bind,
        anonBind,
        toLazy,
        toCached,
        toPromise,
        get
    };
};
const nu = (baseFn) => {
    return make(() => new Promise(baseFn));
};
/** a -> Future a */
const pure = (a) => {
    return make(() => Promise.resolve(a));
};
export const Future = {
    nu,
    pure
};
//# sourceMappingURL=Future.js.map
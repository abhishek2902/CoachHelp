import * as Type from './Type';
const noop = () => { };
const noarg = (f) => () => f();
/** Compose a unary function with an n-ary function */
const compose = (fa, fb) => {
    return (...args) => {
        return fa(fb.apply(null, args));
    };
};
/** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */
const compose1 = (fbc, fab) => (a) => fbc(fab(a));
const constant = (value) => {
    return () => {
        return value;
    };
};
const identity = (x) => {
    return x;
};
const tripleEquals = (a, b) => {
    return a === b;
};
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function curry(fn, ...initialArgs) {
    return (...restArgs) => {
        const all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
    };
}
const not = (f) => (t) => !f(t);
const die = (msg) => {
    return () => {
        throw new Error(msg);
    };
};
const apply = (f) => {
    return f();
};
const call = (f) => {
    f();
};
const never = constant(false);
const always = constant(true);
/* Used to weaken types */
const weaken = (b) => b;
const pipe = (a, ab, bc, cd, de, ef, fg, gh) => {
    const b = ab(a);
    if (Type.isNullable(bc)) {
        return b;
    }
    const c = bc(b);
    if (Type.isNullable(cd)) {
        return c;
    }
    const d = cd(c);
    if (Type.isNullable(de)) {
        return d;
    }
    const e = de(d);
    if (Type.isNullable(ef)) {
        return e;
    }
    const f = ef(e);
    if (Type.isNullable(fg)) {
        return f;
    }
    const g = fg(f);
    if (Type.isNullable(gh)) {
        return g;
    }
    return gh(g);
};
export { noop, noarg, compose, compose1, constant, identity, tripleEquals, curry, not, die, apply, call, never, always, weaken, pipe };
//# sourceMappingURL=Fun.js.map
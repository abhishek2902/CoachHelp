import { Merger, Obj } from '@ephox/katamari';
import { Attribute, Css, InsertAll } from '@ephox/sugar';
import * as fc from 'fast-check';
import * as ArbChildrenSchema from './ArbChildrenSchema';
import * as ArbNodes from './ArbNodes';
import * as WeightedChoice from './WeightedChoice';
const isTagsDetail = (detail) => detail.tags !== undefined;
const toTags = (detail) => Obj.mapToArray(detail.tags, (v, k) => Merger.deepMerge(v, { tag: k }));
const flattenTag = (tag) => {
    const r = {};
    r[tag] = { weight: 1.0 };
    return r;
};
const conform = (detail) => {
    if (isTagsDetail(detail)) {
        return detail;
    }
    else {
        return Merger.deepMerge(detail, {
            tags: flattenTag(detail.tag)
        });
    }
};
const addDecorations = (detail, element) => {
    const attrDecorator = detail.attributes !== undefined ? detail.attributes : fc.constant({});
    const styleDecorator = detail.styles !== undefined ? detail.styles : fc.constant({});
    return attrDecorator.chain((attrs) => {
        Attribute.setAll(element, attrs);
        return styleDecorator.map((styles) => {
            Css.setAll(element, styles);
            return element;
        });
    });
};
const makeTag = (choice) => {
    const element = ArbNodes.elementOf(choice.tag);
    const attributes = choice.attributes !== undefined ? choice.attributes : {};
    const styles = choice.styles !== undefined ? choice.styles : {};
    Attribute.setAll(element, attributes);
    Css.setAll(element, styles);
    return element;
};
export const create = (construct) => {
    const combine = (detail, childGenerator) => {
        const tags = toTags(conform(detail));
        return WeightedChoice.generator(tags).chain((choiceOption) => {
            const choice = choiceOption.getOrDie('Every entry in tags for: ' + JSON.stringify(detail) + ' must have a tag');
            return childGenerator.chain((children) => {
                const parent = makeTag(choice);
                InsertAll.append(parent, children);
                // Use any style and attribute decorators.
                return addDecorations(detail, parent);
            });
        });
    };
    const composite = (detail) => (rawDepth) => {
        const childGenerator = ArbChildrenSchema.composite(rawDepth, detail, construct);
        return combine(detail, childGenerator);
    };
    const leaf = (detail) => (_) => combine(detail, ArbChildrenSchema.none);
    const structure = (detail) => (rawDepth) => {
        const childGenerator = ArbChildrenSchema.structure(rawDepth, detail, construct);
        return combine(detail, childGenerator);
    };
    const arbitrary = (arb) => (_) => arb.component;
    return {
        arbitrary,
        leaf,
        structure,
        composite
    };
};
//# sourceMappingURL=ArbSchemaTypes.js.map
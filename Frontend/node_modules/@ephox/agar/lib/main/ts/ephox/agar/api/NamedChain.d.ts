import { Result } from '@ephox/katamari';
import { DieFn, NextFn } from '../pipe/Pipe';
import { Chain } from './Chain';
import { TestLogs } from './TestLogs';
export type NamedData = Record<string, any>;
export type NamedChain = Chain<NamedData, NamedData>;
export declare const _outputName: () => string;
export declare const _outputUnset: () => string;
export declare const NamedChain: {
    inputName: () => string;
    asChain: <T>(chains: NamedChain[]) => Chain<T, any>;
    write: (name: string, chain: Chain<NamedData, any>) => Chain<NamedData, NamedData>;
    direct: (inputName: string, chain: Chain<any, any>, outputName: string) => Chain<NamedData, NamedData>;
    writeValue: (name: string, value: any) => Chain<NamedData, NamedData>;
    overwrite: (inputName: string, chain: Chain<any, any>) => Chain<NamedData, NamedData>;
    read: (name: string, chain: Chain<any, any>) => Chain<NamedData, NamedData>;
    merge: (names: string[], combinedName: string) => Chain<NamedData, NamedData>;
    bundle: <T_1, E>(f: (input: NamedData) => Result<T_1, E>) => Chain<NamedData, NamedData>;
    output: (name: string) => Chain<NamedData, NamedData>;
    outputInput: Chain<NamedData, NamedData>;
    pipeline: (namedChains: NamedChain[], onSuccess: NextFn<any>, onFailure: DieFn, initLogs: TestLogs) => void;
};
//# sourceMappingURL=NamedChain.d.ts.map
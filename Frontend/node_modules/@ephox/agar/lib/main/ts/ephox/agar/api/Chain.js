import { Failure } from '@ephox/bedrock-common';
import { Arr, Fun } from '@ephox/katamari';
import * as AsyncActions from '../pipe/AsyncActions';
import * as GeneralActions from '../pipe/GeneralActions';
import { Pipe } from '../pipe/Pipe';
import { addLogging } from './Guard';
import { Pipeline } from './Pipeline';
import { Step } from './Step';
import { addLogEntry, TestLogs } from './TestLogs';
const on = (f) => {
    const runChain = Pipe((input, next, die, logs) => {
        f(input, (v, newLogs) => {
            next(v, newLogs);
        }, (err, newLogs) => die(err, newLogs), logs);
    });
    return {
        runChain
    };
};
const control = (chain, guard) => on((input, next, die, logs) => {
    guard(chain.runChain, input, (v, newLogs) => {
        next(v, newLogs);
    }, die, logs);
});
const mapper = (fx) => on((input, next, die, logs) => {
    next(fx(input), logs);
});
const identity = mapper(Fun.identity);
const binder = (fx) => on((input, next, die, logs) => {
    fx(input).fold((err) => {
        die(err, logs);
    }, (v) => {
        next(v, logs);
    });
});
const op = (fx) => on((input, next, die, logs) => {
    fx(input);
    next(input, logs);
});
const async = (fx) => on((v, n, d, logs) => fx(v, (v) => n(v, logs), (err) => d(err, logs)));
const inject = (value) => on((_input, next, die, logs) => {
    next(value, logs);
});
const injectThunked = (f) => on((_input, next, die, logs) => {
    next(f(), logs);
});
const extract = (chain) => ({
    runStep: chain.runChain
});
const fromChains = (chains) => {
    const cs = Arr.map(chains, extract);
    return on((value, next, die, initLogs) => {
        Pipeline.async(value, cs, (v, newLogs) => next(v, newLogs), die, initLogs);
    });
};
const fromChainsWith = (initial, chains) => fromChains([inject(initial)].concat(chains));
const fromIsolatedChains = (chains) => {
    const cs = Arr.map(chains, extract);
    return on((value, next, die, initLogs) => {
        Pipeline.async(value, cs, (_v, newLogs) => {
            // Ignore the output value and use the original value instead
            next(value, newLogs);
        }, die, initLogs);
    });
};
const fromIsolatedChainsWith = (initial, chains) => fromIsolatedChains([inject(initial)].concat(chains));
// Find the first chain which doesn't fail, and use its value. Fails if no chain passes.
const exists = (chains) => {
    const cs = Arr.map(chains, extract);
    let index = 0;
    const attempt = (value, next, die, initLogs) => {
        let replacementDie = die;
        if (index + 1 < cs.length) {
            replacementDie = () => {
                index += 1;
                attempt(value, next, die, initLogs);
            };
        }
        Pipeline.runStep(value, cs[index], next, replacementDie, initLogs);
    };
    return on(attempt);
};
const fromParent = (parent, chains) => on((cvalue, cnext, cdie, clogs) => {
    Pipeline.async(cvalue, [extract(parent)], (value, parentLogs) => {
        const cs = Arr.map(chains, (c) => Step.raw((_, next, die, logs) => {
            // Replace _ with value
            c.runChain(value, next, die, logs);
        }));
        Pipeline.async(cvalue, cs, (_, finalLogs) => {
            // Ignore all the values and use the original
            cnext(value, finalLogs);
        }, cdie, parentLogs);
    }, cdie, clogs);
});
/**
 * @deprecated Use isolate() instead
 * TODO: remove
 */
const asStep = (initial, chains) => Step.raw((initValue, next, die, logs) => {
    const cs = Arr.map(chains, extract);
    Pipeline.async(initial, cs, 
    // Ignore all the values and use the original
    (_v, ls) => {
        next(initValue, ls);
    }, die, logs);
});
/**
 * Wrap a Chain into an "isolated" Step, with its own local state.
 * The state of the outer Step is passed-through.
 * Use the functions in ChainSequence to compose multiple Chains.
 *
 * @param initial
 * @param chain
 */
const isolate = (initial, chain) => Step.raw((initValue, next, die, logs) => {
    Pipeline.runStep(initial, extract(chain), 
    // Ignore all the values and use the original
    (_v, ls) => {
        next(initValue, ls);
    }, die, logs);
});
// Convenience functions
const debugging = op(GeneralActions.debug);
const log = (message) => on((input, next, die, logs) => {
    // eslint-disable-next-line no-console
    console.log(message);
    next(input, addLogEntry(logs, message));
});
const label = (label, chain) => control(chain, addLogging(label));
const wait = (amount) => on((input, next, die, logs) => {
    AsyncActions.delay(amount)(() => next(input, logs), die);
});
const pipeline = (chains, onSuccess, onFailure, initLogs) => {
    Pipeline.async({}, Arr.map(chains, extract), (output, logs) => {
        onSuccess(output, logs);
    }, onFailure, TestLogs.getOrInit(initLogs));
};
const runStepsOnValue = (getSteps) => Chain.on((input, next, die, initLogs) => {
    const steps = getSteps(input);
    Pipeline.async(input, steps, (stepsOutput, newLogs) => next(stepsOutput, newLogs), die, initLogs);
});
const predicate = (p) => on((input, next, die, logs) => p(input) ? next(input, logs) : die('predicate did not succeed', logs));
const toPromise = (c) => (a) => new Promise((resolve, reject) => {
    c.runChain(a, (b, _logs) => {
        // TODO: What to do with logs? We lose them.
        resolve(b);
    }, (err, logs) => {
        reject(Failure.prepFailure(err, logs));
    }, TestLogs.init());
});
const fromPromise = (f) => Chain.async((input, next, die) => {
    f(input).then(next, die);
});
export const Chain = {
    on,
    op,
    async,
    control,
    mapper,
    identity,
    binder,
    runStepsOnValue,
    inject,
    injectThunked,
    fromChains,
    fromChainsWith,
    fromIsolatedChains,
    fromIsolatedChainsWith,
    exists,
    fromParent,
    asStep,
    isolate,
    wait,
    debugging,
    log,
    label,
    toPromise,
    fromPromise,
    pipeline,
    predicate
};
//# sourceMappingURL=Chain.js.map
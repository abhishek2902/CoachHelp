import { Arr } from '@ephox/katamari';
import { Chain } from './Chain';
export const compose = (sab, sbc) => 
// don't Pipe them - assume that the base actions have already been piped
({
    runChain: (a, next, die, logs) => sab.runChain(a, (b, blogs) => sbc.runChain(b, next, die, blogs), die, logs)
});
/*
Code partly generated in GHCi:

:m + Data.List
:m + Control.Monad
putStrLn $ intercalate " |\n" $ (\n -> (\x -> "[" ++ x ++ ", Chain<A" ++ (show n) ++ ", T>]") $ intercalate ", " $ (\m -> "Chain<A" ++ (show m) ++ ", A" ++ (show (m + 1)) ++ ">") <$> [1..n-1]) <$> [1..100]
 */
/* eslint-disable max-len */
export const sequence = (Chains) => {
    const s = Chains;
    return sequenceUnsafe(s);
};
/* eslint-enable max-len */
export const sequenceSame = (Chains) => sequenceUnsafe(Chains);
export const sequenceUnsafe = (Chains) => Chains.length === 0 ? Chain.identity : Arr.foldl(Chains, (acc, Chain) => compose(acc, Chain), Chain.identity);
//# sourceMappingURL=ChainSequence.js.map
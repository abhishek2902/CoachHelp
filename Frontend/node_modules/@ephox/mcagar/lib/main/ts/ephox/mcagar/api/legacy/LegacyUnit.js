import { Assertions, Logger, Step } from '@ephox/agar';
import { TinyDom } from '../TinyDom';
const test = (message, fn) => {
    return (initValue) => {
        return Logger.t(message, Step.sync(() => {
            fn(initValue);
        }));
    };
};
const asyncTest = (message, fn) => {
    return (initValue) => {
        return Logger.t(message, Step.async((done, die) => {
            fn(initValue, done, die);
        }));
    };
};
const createSuite = () => {
    const tests = [];
    return {
        test: (message, fn) => {
            tests.push(test(message, fn));
        },
        asyncTest: (message, fn) => {
            tests.push(asyncTest(message, fn));
        },
        toSteps: (initValue) => {
            return tests.map((test) => {
                return test(initValue);
            });
        }
    };
};
const execCommand = (editor, cmd, ui, value) => {
    if (editor.editorCommands.queryCommandSupported(cmd)) {
        editor.execCommand(cmd, ui, value);
    }
};
const findContainer = (editor, selector) => {
    let container;
    if (typeof selector === 'string') {
        container = editor.dom.select(selector)[0];
    }
    else {
        container = selector;
    }
    if (container.firstChild) {
        container = container.firstChild;
    }
    return container;
};
const setSelection = (editor, startSelector, startOffset, endSelector, endOffset) => {
    const startContainer = findContainer(editor, startSelector);
    const endContainer = findContainer(editor, endSelector ? endSelector : startSelector);
    const rng = editor.dom.createRng();
    const setRange = (container, offset, start) => {
        offset = offset ? offset : 0;
        if (offset === 'after') {
            if (start) {
                rng.setStartAfter(container);
            }
            else {
                rng.setEndAfter(container);
            }
            return;
        }
        else if (offset === 'afterNextCharacter') {
            container = container.nextSibling;
            offset = 1;
        }
        if (start) {
            rng.setStart(container, offset);
        }
        else {
            rng.setEnd(container, offset);
        }
    };
    setRange(startContainer, startOffset, true);
    setRange(endContainer, endSelector ? endOffset : startOffset, false);
    editor.selection.setRng(rng);
};
const trimBrs = (html) => {
    return html.toLowerCase().replace(/<br[^>]*>|[\r\n]+/gi, '');
};
const equalDom = (actual, expected, message) => {
    Assertions.assertDomEq(typeof message !== 'undefined' ? message : 'Nodes are not equal', TinyDom.fromDom(expected), TinyDom.fromDom(actual));
};
const equal = (actual, expected, message) => {
    Assertions.assertEq(typeof message !== 'undefined' ? message : 'No message specified', expected, actual);
};
const strictEqual = equal;
const deepEqual = equal;
export { test, asyncTest, createSuite, execCommand, setSelection, trimBrs, equal, equalDom, strictEqual, deepEqual };
//# sourceMappingURL=LegacyUnit.js.map
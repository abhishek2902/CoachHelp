import { Arr } from '@ephox/katamari';
import { Step } from './Step';
export const compose = (sab, sbc) => 
// don't Pipe them - assume that the base actions have already been piped
({
    runStep: (a, next, die, logs) => sab.runStep(a, (b, blogs) => sbc.runStep(b, next, die, blogs), die, logs)
});
/*
Code partly generated in GHCi:

:m + Data.List
:m + Control.Monad
putStrLn $ intercalate " |\n" $ (\n -> (\x -> "[" ++ x ++ ", Step<A" ++ (show n) ++ ", T>]") $ intercalate ", " $ (\m -> "Step<A" ++ (show m) ++ ", A" ++ (show (m + 1)) ++ ">") <$> [1..n-1]) <$> [1..100]
 */
/* eslint-disable max-len */
export const sequence = (steps) => {
    const s = steps;
    return sequenceUnsafe(s);
};
/* eslint-enable max-len */
export const sequenceSame = (steps) => sequenceUnsafe(steps);
export const sequenceUnsafe = (steps) => steps.length === 0 ? Step.pass : Arr.foldl(steps, (acc, step) => compose(acc, step), Step.pass);
//# sourceMappingURL=StepSequence.js.map
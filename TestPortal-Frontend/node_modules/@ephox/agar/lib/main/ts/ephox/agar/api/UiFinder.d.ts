import { Result } from '@ephox/katamari';
import { SugarElement } from '@ephox/sugar';
import { Chain } from './Chain';
import { Step } from './Step';
declare const findIn: <T extends Element>(container: SugarElement<Node>, selector: string) => Result<SugarElement<T>, import("@ephox/bedrock-common").TestLabel>;
declare const findAllIn: <T extends Element>(container: SugarElement<Node>, selector: string) => SugarElement<T>[];
declare const exists: (container: SugarElement<Node>, selector: string) => void;
declare const notExists: (container: SugarElement<Node>, selector: string) => void;
declare const cWaitFor: <T extends Element>(message: string, selector: string) => Chain<SugarElement<Node>, SugarElement<T>>;
declare const sWaitFor: <T>(message: string, container: SugarElement<Node>, selector: string) => Step<T, T>;
declare const cWaitForVisible: <T extends HTMLElement>(message: string, selector: string) => Chain<SugarElement<Node>, SugarElement<T>>;
declare const cWaitForHidden: <T extends HTMLElement>(message: string, selector: string) => Chain<SugarElement<Node>, SugarElement<T>>;
declare const sWaitForVisible: <T>(message: string, container: SugarElement<Node>, selector: string) => Step<T, T>;
declare const sWaitForHidden: <T>(message: string, container: SugarElement<Node>, selector: string) => Step<T, T>;
declare const cWaitForState: <T extends Element>(message: string, selector: string, predicate: (element: SugarElement<T>) => boolean) => Chain<SugarElement<Node>, SugarElement<T>>;
declare const sExists: <T>(container: SugarElement<Node>, selector: string) => Step<T, T>;
declare const sNotExists: <T>(container: SugarElement<Node>, selector: string) => Step<T, T>;
declare const cExists: <T extends Node>(selector: string) => Chain<SugarElement<T>, SugarElement<T>>;
declare const cNotExists: <T extends Node>(selector: string) => Chain<SugarElement<T>, SugarElement<T>>;
declare const cFindIn: (selector: string) => Chain<SugarElement<Node>, SugarElement<Element>>;
declare const cFindAllIn: <T extends Element>(selector: string) => Chain<SugarElement<Node>, SugarElement<T>[]>;
declare const pWaitFor: <T extends Element>(message: string, container: SugarElement<Node>, selector: string) => Promise<SugarElement<T>>;
declare const pWaitForVisible: <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string) => Promise<SugarElement<T>>;
declare const pWaitForHidden: <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string) => Promise<SugarElement<T>>;
declare const pWaitForState: <T extends Element>(message: string, container: SugarElement<Node>, selector: string, predicate: (element: SugarElement<T>) => boolean) => Promise<SugarElement<T>>;
export { findIn, findAllIn, exists, notExists, sExists, sNotExists, sWaitFor, sWaitForVisible, sWaitForHidden, cExists, cNotExists, cWaitFor, cWaitForVisible, cWaitForHidden, cWaitForState, cFindIn, cFindAllIn, pWaitFor, pWaitForVisible, pWaitForHidden, pWaitForState };
//# sourceMappingURL=UiFinder.d.ts.map
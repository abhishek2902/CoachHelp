import { Arr, Fun, Merger, Obj } from '@ephox/katamari';
import * as fc from 'fast-check';
import * as WeightedChoice from './WeightedChoice';
const skipChild = '_';
const toComponents = (detail) => Obj.mapToArray(detail.components, (v, k) => 
// If there is no component, then the choice will be None.
k !== skipChild ? Merger.deepMerge(v, { component: k }) : v);
const none = fc.constant([]);
const composite = (rawDepth, detail, construct) => {
    const components = toComponents(detail);
    const depth = rawDepth !== null && rawDepth !== void 0 ? rawDepth : detail.recursionDepth;
    if (depth === 0) {
        return none;
    }
    else {
        const genComponent = (choice, depth) => {
            const newDepth = choice.useDepth === true ? depth - 1 : depth;
            return fc.array(construct(choice.component, newDepth), { minLength: 1, maxLength: 5 });
        };
        const repeat = WeightedChoice.generator(components).chain((choice) => choice.fold(Fun.constant(none), (c) => genComponent(c, depth)));
        return fc.array(repeat, { minLength: 1, maxLength: 5 }).map(Arr.flatten);
    }
};
const structure = (rawDepth, detail, construct) => {
    const components = toComponents(detail);
    return fc.float({ min: 0, max: 1 }).chain((random) => {
        // TODO: Allow the order to be mixed up?
        const children = Arr.foldl(components, (b, component) => random <= component.chance ?
            b.concat([construct(component.component, rawDepth)]) :
            b, []);
        return fc.tuple(...children);
    });
};
export { none, composite, structure };
//# sourceMappingURL=ArbChildrenSchema.js.map
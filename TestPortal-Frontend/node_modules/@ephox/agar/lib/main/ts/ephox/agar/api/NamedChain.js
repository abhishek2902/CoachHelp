import { Arr, Fun, Id, Obj } from '@ephox/katamari';
import { Chain } from './Chain';
const inputNameId = Id.generate('input-name');
const outputNameId = Id.generate('output-name');
const outputUnset = Id.generate('output-unset');
const asChain = (chains) => Chain.fromChains(Arr.flatten([
    [Chain.mapper((input) => ({
            [inputNameId]: input,
            [outputNameId]: outputUnset
        }))],
    chains,
    [Chain.mapper((data) => {
            const output = data[outputNameId];
            delete data[outputNameId];
            return output === outputUnset ? data : output;
        })]
]));
// Write merges in its output into input because it knows that it was
// given a complete input.
const write = (name, chain) => Chain.on((input, next, die, initLogs) => {
    chain.runChain(input, (output, newLogs) => {
        const self = wrapSingle(name, output);
        return next({ ...input, ...self }, newLogs);
    }, die, initLogs);
});
// Partial write does not try and merge in input, because it knows that it
// might not be getting the full input
const partialWrite = (name, chain) => Chain.on((input, next, die, initLogs) => {
    chain.runChain(input, (output, newLogs) => {
        const self = wrapSingle(name, output);
        return next(self, newLogs);
    }, die, initLogs);
});
const wrapSingle = (name, value) => {
    if (name === '_') {
        return {};
    }
    return {
        [name]: value
    };
};
const combine = (input, name, value) => ({ ...input, ...wrapSingle(name, value) });
const process = (name, chain) => Chain.on((input, next, die, initLogs) => {
    if (Obj.has(input, name)) {
        const part = input[name];
        chain.runChain(part, (other, newLogs) => {
            const merged = { ...input, ...other };
            next(merged, newLogs);
        }, die, initLogs);
    }
    else {
        die(name + ' is not a field in the index object.', initLogs);
    }
});
const direct = (inputName, chain, outputName) => process(inputName, partialWrite(outputName, chain));
const overwrite = (inputName, chain) => direct(inputName, chain, inputName);
const writeValue = (name, value) => Chain.mapper((input) => combine(input, name, value));
const read = (name, chain) => Chain.on((input, next, die, initLogs) => {
    chain.runChain(input[name], (_, newLogs) => next(input, newLogs), die, initLogs);
});
const merge = (names, combinedName) => Chain.mapper((input) => {
    const r = {};
    Arr.each(names, (name) => {
        r[name] = input[name];
    });
    return combine(input, combinedName, r);
});
const bundle = (f) => write(outputNameId, Chain.binder(f));
const output = (name) => direct(name, Chain.identity, outputNameId);
const outputInput = output(inputNameId);
const pipeline = (namedChains, onSuccess, onFailure, initLogs) => {
    Chain.pipeline([asChain(namedChains)], onSuccess, onFailure, initLogs);
};
const inputName = Fun.constant(inputNameId);
// tests need these values but other users should not
export const _outputName = Fun.constant(outputNameId);
export const _outputUnset = Fun.constant(outputUnset);
export const NamedChain = {
    inputName,
    asChain,
    write,
    direct,
    writeValue,
    overwrite,
    read,
    merge,
    bundle,
    output,
    outputInput,
    pipeline
};
//# sourceMappingURL=NamedChain.js.map
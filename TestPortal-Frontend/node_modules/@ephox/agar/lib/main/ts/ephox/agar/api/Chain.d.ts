import { Result } from '@ephox/katamari';
import { DieFn, NextFn, RunFn } from '../pipe/Pipe';
import { GuardFn } from './Guard';
import { Step } from './Step';
import { TestLogs } from './TestLogs';
export interface Chain<T, U> {
    runChain: RunFn<T, U>;
}
export type ChainGuard<T, U, V> = GuardFn<T, U, V>;
export declare const Chain: {
    on: <T, U>(f: (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void) => Chain<T, U>;
    op: <T_1>(fx: (value: T_1) => void) => Chain<T_1, T_1>;
    async: <T_2, U_1>(fx: (input: T_2, next: (v: U_1) => void, die: (err: any) => void) => void) => Chain<T_2, U_1>;
    control: <T_3, U_2, V>(chain: Chain<T_3, U_2>, guard: ChainGuard<T_3, U_2, V>) => Chain<T_3, V>;
    mapper: <T_4, U_3>(fx: (value: T_4) => U_3) => Chain<T_4, U_3>;
    identity: Chain<unknown, unknown>;
    binder: <T_5, U_4, E>(fx: (input: T_5) => Result<U_4, E>) => Chain<T_5, U_4>;
    runStepsOnValue: <I, O>(getSteps: (value: I) => Step<I, O>[]) => Chain<I, O>;
    inject: <T_6, U_5>(value: U_5) => Chain<T_6, U_5>;
    injectThunked: <T_7, U_6>(f: () => U_6) => Chain<T_7, U_6>;
    fromChains: <T_8 = any, U_7 = any>(chains: Chain<any, any>[]) => Chain<T_8, U_7>;
    fromChainsWith: <T_9, U_8 = any, V_1 = any>(initial: T_9, chains: Chain<any, any>[]) => Chain<U_8, V_1>;
    fromIsolatedChains: <T_10 = any>(chains: Chain<any, any>[]) => Chain<T_10, T_10>;
    fromIsolatedChainsWith: <T_11, U_9 = any>(initial: T_11, chains: Chain<any, any>[]) => Chain<U_9, U_9>;
    exists: <T_12, U_10>(chains: Chain<T_12, U_10>[]) => Chain<T_12, U_10>;
    fromParent: <T_13, U_11, V_2>(parent: Chain<T_13, U_11>, chains: Chain<U_11, V_2>[]) => Chain<T_13, U_11>;
    asStep: <T_14, U_12>(initial: U_12, chains: Chain<any, any>[]) => Step<T_14, T_14>;
    isolate: <T_15, U_13, V_3>(initial: U_13, chain: Chain<U_13, V_3>) => Step<T_15, T_15>;
    wait: <T_16>(amount: number) => Chain<T_16, T_16>;
    debugging: Chain<unknown, unknown>;
    log: <T_17>(message: string) => Chain<T_17, T_17>;
    label: <T_18, U_14>(label: string, chain: Chain<T_18, U_14>) => Chain<T_18, U_14>;
    toPromise: <A, B>(c: Chain<A, B>) => (a: A) => Promise<B>;
    fromPromise: <A_1, B_1>(f: (a: A_1) => Promise<B_1>) => Chain<A_1, B_1>;
    pipeline: (chains: Chain<any, any>[], onSuccess: NextFn<any>, onFailure: DieFn, initLogs?: TestLogs) => void;
    predicate: <T_19>(p: (value: T_19) => boolean) => Chain<T_19, T_19>;
};
//# sourceMappingURL=Chain.d.ts.map
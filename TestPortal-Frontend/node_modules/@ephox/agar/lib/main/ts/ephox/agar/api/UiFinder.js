import { Fun, Result } from '@ephox/katamari';
import { Truncate, Visibility } from '@ephox/sugar';
import * as UiSearcher from '../find/UiSearcher';
import { Chain } from './Chain';
import * as Guard from './Guard';
import { Step } from './Step';
const findIn = UiSearcher.findIn;
const findAllIn = UiSearcher.findAllIn;
const exists = (container, selector) => {
    findIn(container, selector).fold(() => {
        throw new Error('Expected ' + selector + ' to exist.');
    }, Fun.noop);
};
const notExists = (container, selector) => {
    return findIn(container, selector).fold(Fun.noop, () => {
        throw new Error('Expected ' + selector + ' not to exist.');
    });
};
const cWaitFor = (message, selector) => cWaitForState(message, selector, Fun.always);
const sWaitFor = (message, container, selector) => Chain.asStep(container, [cWaitFor(message, selector)]);
const cWaitForVisible = (message, selector) => cWaitForState(message, selector, Visibility.isVisible);
// TODO: Perhaps create cWaitForNoState rather than Fun.not here?
const cWaitForHidden = (message, selector) => cWaitForState(message, selector, Fun.not(Visibility.isVisible));
const sWaitForVisible = (message, container, selector) => Chain.asStep(container, [cWaitForVisible(message, selector)]);
const sWaitForHidden = (message, container, selector) => Chain.asStep(container, [cWaitForHidden(message, selector)]);
const cHasState = (predicate) => Chain.binder((element) => predicate(element) ? Result.value(element) :
    Result.error(Truncate.getHtml(element) + ' did not match predicate: ' + predicate.toString()));
const cFindWithState = (selector, predicate) => Chain.fromChains([
    cFindIn(selector),
    cHasState(predicate)
]);
// Wait for a selector to have state. Max wait time: 10 seconds.
const cWaitForState = (message, selector, predicate) => Chain.control(cFindWithState(selector, predicate), Guard.tryUntil(message, 10, 10000));
const sExists = (container, selector) => Step.sync(() => exists(container, selector));
const sNotExists = (container, selector) => Step.sync(() => notExists(container, selector));
const cExists = (selector) => Chain.op((container) => exists(container, selector));
const cNotExists = (selector) => Chain.op((container) => notExists(container, selector));
const cFindIn = (selector) => Chain.binder((container) => findIn(container, selector));
const cFindAllIn = (selector) => Chain.mapper((container) => findAllIn(container, selector));
const pWaitFor = (message, container, selector) => Chain.toPromise(cWaitFor(message, selector))(container);
const pWaitForVisible = (message, container, selector) => Chain.toPromise(cWaitForVisible(message, selector))(container);
const pWaitForHidden = (message, container, selector) => Chain.toPromise(cWaitForHidden(message, selector))(container);
const pWaitForState = (message, container, selector, predicate) => Chain.toPromise(cWaitForState(message, selector, predicate))(container);
export { findIn, findAllIn, exists, notExists, sExists, sNotExists, sWaitFor, sWaitForVisible, sWaitForHidden, cExists, cNotExists, cWaitFor, cWaitForVisible, cWaitForHidden, cWaitForState, cFindIn, cFindAllIn, pWaitFor, pWaitForVisible, pWaitForHidden, pWaitForState };
//# sourceMappingURL=UiFinder.js.map
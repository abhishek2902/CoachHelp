import { Result } from '@ephox/katamari';
import { Hierarchy } from '@ephox/sugar';
import { Chain } from './Chain';
const range = (obj) => ({
    start: obj.start,
    soffset: obj.soffset,
    finish: obj.finish,
    foffset: obj.foffset
});
const path = (obj) => ({
    startPath: obj.startPath,
    soffset: obj.soffset,
    finishPath: obj.finishPath,
    foffset: obj.foffset
});
const pathFromCollapsed = (spec) => path({
    startPath: spec.element,
    soffset: spec.offset,
    finishPath: spec.element,
    foffset: spec.offset
});
const pathFromRange = (spec) => {
    const finish = spec.finish !== undefined ? spec.finish : spec.start;
    return path({
        startPath: spec.start.element,
        soffset: spec.start.offset,
        finishPath: finish.element,
        foffset: finish.offset
    });
};
const isCursorSpec = (spec) => !('start' in spec) && 'element' in spec;
const pathFrom = (spec) => isCursorSpec(spec) ? pathFromCollapsed(spec) : pathFromRange(spec);
const follow = (container, calcPath) => Hierarchy.follow(container, calcPath).fold(() => Result.error('Could not follow path: ' + calcPath.join(',')), Result.value);
const followPath = (container, calcPath) => follow(container, calcPath.startPath).bind((start) => follow(container, calcPath.finishPath).map((finish) => range({
    start,
    soffset: calcPath.soffset,
    finish,
    foffset: calcPath.foffset
})));
const cFollowPath = (calcPath) => Chain.binder((container) => followPath(container, calcPath));
const cFollowCursor = (elementPath, offset) => Chain.binder((container) => follow(container, elementPath).map((element) => range({
    start: element,
    soffset: offset,
    finish: element,
    foffset: offset
})));
const cFollow = (elementPath) => Chain.binder((container) => follow(container, elementPath));
const cToRange = Chain.mapper(range);
const cToPath = Chain.mapper(path);
const calculate = (container, calcPath) => followPath(container, calcPath).getOrDie();
const calculateOne = (container, calcPath) => follow(container, calcPath).getOrDie();
export { range, path, pathFrom, follow, followPath, cFollow, cFollowPath, cFollowCursor, cToRange, cToPath, calculate, calculateOne };
//# sourceMappingURL=Cursors.js.map
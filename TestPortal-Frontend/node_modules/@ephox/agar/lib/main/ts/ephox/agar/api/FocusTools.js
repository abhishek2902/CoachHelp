import { Result } from '@ephox/katamari';
import { Compare, Focus, SugarShadowDom, Truncate } from '@ephox/sugar';
import * as SizzleFind from '../alien/SizzleFind';
import { Chain } from './Chain';
import * as Guard from './Guard';
import * as Logger from './Logger';
import { Step } from './Step';
import * as UiControls from './UiControls';
import * as UiFinder from './UiFinder';
import * as Waiter from './Waiter';
const getFocused = (doc) => {
    return Focus.active(doc).fold(() => Result.error('Could not find active element'), Result.value);
};
const getActiveValue = (element) => {
    const doc = SugarShadowDom.getRootNode(element);
    const focused = getFocused(doc).getOrDie();
    return UiControls.getValue(focused);
};
const setFocus = (container, selector) => {
    const elem = UiFinder.findIn(container, selector).getOrDie();
    Focus.focus(elem);
    return elem;
};
const setActiveValue = (doc, newValue) => {
    const focused = getFocused(doc).getOrDie();
    UiControls.setValue(focused, newValue);
    return focused;
};
const isOn = (label, element) => {
    const doc = SugarShadowDom.getRootNode(element);
    return getFocused(doc).bind((active) => {
        return Compare.eq(element, active) ? Result.value(active) : Result.error(label + '\nExpected focus: ' + Truncate.getHtml(element) + '\nActual focus: ' + Truncate.getHtml(active));
    }).getOrDie();
};
const isOnSelector = (label, doc, selector) => {
    return getFocused(doc).bind((active) => {
        return SizzleFind.matches(active, selector) ? Result.value(active) : Result.error(label + '\nExpected focus $("' + selector + '")]\nActual focus: ' + Truncate.getHtml(active));
    }).getOrDie();
};
const cGetFocused = Chain.binder(getFocused);
const cGetRootNode = Chain.mapper(SugarShadowDom.getRootNode);
const wrapInResult = (f) => () => {
    try {
        return Result.value(f());
    }
    catch (e) {
        return Result.error(e.message);
    }
};
const sIsOn = (label, element) => Chain.asStep(element, [
    Chain.binder(wrapInResult(() => isOn(label, element)))
]);
const sIsOnSelector = (label, doc, selector) => Logger.t(`${label}: sIsOnSelector(${selector})`, Chain.asStep(doc, [
    Chain.binder(wrapInResult(() => isOnSelector(label, doc, selector)))
]));
const sTryOnSelector = (label, doc, selector) => Logger.t(label + '. Focus did not match: ' + selector, Waiter.sTryUntil('Waiting for focus', sIsOnSelector(label, doc, selector), 10, 4000));
const pTryOnSelector = (label, doc, selector) => Waiter.pTryUntil(label + '. Focus did not match: ' + selector, () => isOnSelector(label, doc, selector));
const cSetFocus = (label, selector) => 
// Input: container
Chain.control(Chain.mapper((container) => setFocus(container, selector)), Guard.addLogging(label));
const cSetActiveValue = (newValue) => 
// Input: container
Chain.fromChains([
    cGetRootNode,
    Chain.mapper((root) => setActiveValue(root, newValue))
]);
// Input: container
const cGetActiveValue = Chain.fromChains([
    cGetRootNode,
    cGetFocused,
    UiControls.cGetValue
]);
const sSetFocus = (label, container, selector) => Chain.asStep(container, [cSetFocus(label, selector)]);
const sSetActiveValue = (doc, newValue) => Step.sync(() => setActiveValue(doc, newValue));
export { getActiveValue, setActiveValue, setFocus, getFocused, isOn, isOnSelector, pTryOnSelector, sSetActiveValue, sSetFocus, sIsOn, sIsOnSelector, sTryOnSelector, cSetFocus, cSetActiveValue, cGetActiveValue, cGetFocused };
//# sourceMappingURL=FocusTools.js.map
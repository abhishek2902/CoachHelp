import { after, afterEach, before } from '@ephox/bedrock-client';
import { Arr, Fun, Optional } from '@ephox/katamari';
import { Insert, Remove, SugarBody, SugarElement, SugarShadowDom } from '@ephox/sugar';
import * as Loader from '../../loader/Loader';
import { setupTinymceBaseUrl } from '../../loader/Urls';
const hookNotRun = Fun.die('The setup hooks have not run yet');
const setupHooks = (settings, setupModules, focusOnInit, setupElement) => {
    let lazyEditor = hookNotRun;
    let teardownEditor = Fun.noop;
    let setup = Optional.none();
    let hasFailure = false;
    before(function (done) {
        // TINY-7039: Double the timeout as sometimes 2s wasn't enough for more complex editor loads
        this.timeout(4000);
        setup = setupElement();
        Loader.setup({
            preInit: (tinymce, settings) => {
                setupTinymceBaseUrl(tinymce, settings);
                Arr.each(setupModules, Fun.call);
            },
            run: (ed, success) => {
                lazyEditor = Fun.constant(ed);
                teardownEditor = success;
                if (focusOnInit) {
                    ed.focus();
                }
                done();
            },
            success: Fun.noop,
            failure: done
        }, settings, setup.map((s) => s.element));
    });
    afterEach(function () {
        var _a;
        if (((_a = this.currentTest) === null || _a === void 0 ? void 0 : _a.isFailed()) === true) {
            hasFailure = true;
        }
    });
    after(() => {
        if (!hasFailure) {
            teardownEditor();
            setup.each((s) => s.teardown());
        }
        // Cleanup references
        lazyEditor = hookNotRun;
        teardownEditor = Fun.noop;
        setup = Optional.none();
    });
    return {
        editor: () => lazyEditor()
    };
};
const bddSetup = (settings, setupModules = [], focusOnInit = false) => {
    return setupHooks(settings, setupModules, focusOnInit, Optional.none);
};
const bddSetupLight = (settings, setupModules = [], focusOnInit = false) => {
    return setupHooks({
        toolbar: '',
        menubar: false,
        statusbar: false,
        ...settings
    }, setupModules, focusOnInit, Optional.none);
};
const bddSetupFromElement = (settings, setupElement, setupModules = [], focusOnInit = false) => {
    return setupHooks(settings, setupModules, focusOnInit, () => Optional.some(setupElement()));
};
const bddSetupInShadowRoot = (settings, setupModules = [], focusOnInit = false) => {
    let lazyShadowRoot = hookNotRun;
    let editorDiv;
    let teardown = Fun.noop;
    before(function () {
        if (!SugarShadowDom.isSupported()) {
            this.skip();
        }
        const shadowHost = SugarElement.fromTag('div', document);
        Insert.append(SugarBody.body(), shadowHost);
        const sr = SugarElement.fromDom(shadowHost.dom.attachShadow({ mode: 'open' }));
        const div = SugarElement.fromTag('div', document);
        Insert.append(sr, div);
        lazyShadowRoot = Fun.constant(sr);
        editorDiv = Optional.some(div);
        teardown = () => {
            Remove.remove(shadowHost);
            // Cleanup references
            lazyShadowRoot = hookNotRun;
            editorDiv = Optional.none();
            teardown = Fun.noop;
        };
    });
    const hooks = setupHooks(settings, setupModules, focusOnInit, () => editorDiv.map((element) => ({ element, teardown })));
    return {
        ...hooks,
        shadowRoot: () => lazyShadowRoot()
    };
};
export { bddSetup, bddSetupLight, bddSetupFromElement, bddSetupInShadowRoot };
//# sourceMappingURL=TinyHooks.js.map
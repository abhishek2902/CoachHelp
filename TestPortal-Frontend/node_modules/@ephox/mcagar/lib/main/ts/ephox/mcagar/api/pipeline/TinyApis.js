import { Assertions, Chain, Step, Waiter } from '@ephox/agar';
import { Fun } from '@ephox/katamari';
import * as Options from '../../alien/Options';
import * as TinyAssertions from '../bdd/TinyAssertions';
import * as TinySelections from '../bdd/TinySelections';
export const TinyApis = (editor) => {
    const getContent = () => editor.getContent();
    const setContent = (html) => {
        editor.setContent(html);
    };
    const setRawContent = (html) => {
        editor.getBody().innerHTML = html;
    };
    const nodeChanged = () => {
        editor.nodeChanged();
    };
    const setSelectionFrom = Fun.curry(TinySelections.setSelectionFrom, editor);
    const setCursor = Fun.curry(TinySelections.setCursor, editor);
    const setSelection = Fun.curry(TinySelections.setSelection, editor);
    const select = Fun.curry(TinySelections.select, editor);
    const setOption = (key, value) => {
        Options.set(editor, key, value);
    };
    const unsetOption = (key) => {
        Options.unset(editor, key);
    };
    const execCommand = (command, value) => {
        editor.execCommand(command, false, value);
    };
    const assertContent = Fun.curry(TinyAssertions.assertContent, editor);
    const assertContentPresence = Fun.curry(TinyAssertions.assertContentPresence, editor);
    const assertContentStructure = Fun.curry(TinyAssertions.assertContentStructure, editor);
    const assertSelection = Fun.curry(TinyAssertions.assertSelection, editor);
    const focus = () => {
        editor.focus();
    };
    const hasFocus = (expected) => {
        Assertions.assertEq('Assert whether editor hasFocus', expected, editor.hasFocus());
    };
    const sSetContent = (html) => Step.sync(() => {
        setContent(html);
    });
    const sSetRawContent = (html) => Step.sync(() => {
        setRawContent(html);
    });
    // Has to be thunked, so it can remain polymorphic
    const cNodeChanged = () => Chain.op(nodeChanged);
    const sSetSelectionFrom = (spec) => Step.sync(() => {
        setSelectionFrom(spec);
    });
    const sSetCursor = (elementPath, offset) => sSetSelection(elementPath, offset, elementPath, offset);
    const sSetSelection = (startPath, soffset, finishPath, foffset) => Step.sync(() => {
        setSelection(startPath, soffset, finishPath, foffset);
    });
    const sSetOption = (key, value) => Step.sync(() => {
        setOption(key, value);
    });
    const sUnsetOption = (key) => Step.sync(() => {
        unsetOption(key);
    });
    const sSelect = (selector, path) => Step.sync(() => {
        TinySelections.select(editor, selector, path);
    });
    const cGetContent = () => Chain.injectThunked(getContent);
    const sExecCommand = (command, value) => Step.sync(() => {
        execCommand(command, value);
    });
    const sAssertContent = (expected) => Step.sync(() => {
        assertContent(expected);
    });
    const sAssertContentPresence = (expected) => Step.sync(() => {
        assertContentPresence(expected);
    });
    const sAssertContentStructure = (expected) => Step.sync(() => {
        assertContentStructure(expected);
    });
    const sAssertSelection = (startPath, soffset, finishPath, foffset) => Step.sync(() => {
        assertSelection(startPath, soffset, finishPath, foffset);
    });
    const sFocus = () => Step.sync(focus);
    const sHasFocus = (expected) => Step.sync(() => {
        hasFocus(expected);
    });
    const sNodeChanged = () => Step.sync(nodeChanged);
    const sTryAssertFocus = (waitTime) => Waiter.sTryUntil('Waiting for focus', sHasFocus(true), 50, waitTime);
    const pTryAssertFocus = (waitTime) => Step.toPromise(sTryAssertFocus(waitTime))(undefined);
    return {
        getContent,
        setContent,
        setRawContent,
        nodeChanged,
        setSelectionFrom,
        setCursor,
        setSelection,
        select,
        setSetting: setOption,
        deleteSetting: unsetOption,
        setOption,
        unsetOption,
        execCommand,
        assertContent,
        assertContentStructure,
        assertContentPresence,
        assertSelection,
        focus,
        hasFocus,
        pTryAssertFocus,
        sSetContent,
        cGetContent,
        sSetRawContent,
        cNodeChanged,
        sAssertContent,
        sAssertContentPresence,
        sAssertContentStructure,
        sSetSelectionFrom,
        sSetSelection,
        sSetSetting: sSetOption,
        sDeleteSetting: sUnsetOption,
        sSetOption,
        sUnsetOption,
        sSetCursor,
        sSelect,
        sExecCommand,
        sAssertSelection,
        sTryAssertFocus,
        sFocus,
        sHasFocus,
        sNodeChanged
    };
};
//# sourceMappingURL=TinyApis.js.map
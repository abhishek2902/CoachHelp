import { Chain, Guard, Mouse, NamedChain, UiFinder } from '@ephox/agar';
import { Fun } from '@ephox/katamari';
import { SugarBody, SugarElement, Visibility } from '@ephox/sugar';
import { getThemeSelectors } from '../ThemeSelectors';
const cToolstripRoot = Chain.mapper((editor) => {
    return SugarElement.fromDom(editor.getContainer());
});
const cEditorRoot = Chain.mapper((editor) => {
    return SugarElement.fromDom(editor.getBody());
});
const cDialogRoot = Chain.injectThunked(SugarBody.body);
const cGetToolbarRoot = NamedChain.asChain([
    NamedChain.direct(NamedChain.inputName(), Chain.identity, 'editor'),
    NamedChain.direct('editor', cToolstripRoot, 'container'),
    NamedChain.merge(['editor', 'container'], 'data'),
    NamedChain.direct('data', Chain.binder((data) => UiFinder.findIn(data.container, getThemeSelectors().toolBarSelector(data.editor))), 'toolbar'),
    NamedChain.output('toolbar')
]);
const cGetMenuRoot = Chain.fromChains([
    cToolstripRoot,
    Chain.binder((container) => UiFinder.findIn(container, getThemeSelectors().menuBarSelector))
]);
const cClickOnWithin = (label, selector, cContext) => {
    return Chain.control(NamedChain.asChain([
        NamedChain.direct(NamedChain.inputName(), cContext, 'context'),
        NamedChain.direct('context', UiFinder.cFindIn(selector), 'ui'),
        NamedChain.direct('ui', Mouse.cClick, '_'),
        NamedChain.outputInput
    ]), Guard.addLogging(label));
};
const cClickOnUi = (label, selector) => {
    return cClickOnWithin(label, selector, cDialogRoot);
};
const cClickOnToolbar = (label, selector) => {
    return cClickOnWithin(label, selector, cGetToolbarRoot);
};
const cClickOnMenu = (label, selector) => {
    return cClickOnWithin(label, selector, cGetMenuRoot);
};
const cWaitForState = (hasState) => {
    return (label, selector) => {
        return NamedChain.asChain([
            NamedChain.write('element', Chain.fromChains([
                cDialogRoot,
                UiFinder.cWaitForState(label, selector, hasState)
            ])),
            NamedChain.outputInput
        ]);
    };
};
const cWaitForVisible = (label, selector) => {
    return Chain.fromChains([
        cDialogRoot,
        UiFinder.cWaitForState(label, selector, Visibility.isVisible)
    ]);
};
const cWaitForPopup = (label, selector) => {
    return cWaitForState(Visibility.isVisible)(label, selector);
};
const cWaitForUi = (label, selector) => {
    return cWaitForState(Fun.always)(label, selector);
};
const cTriggerContextMenu = (label, target, menu) => {
    return Chain.fromChains([
        cEditorRoot,
        UiFinder.cFindIn(target),
        Mouse.cContextMenu,
        // Ignores input
        cWaitForPopup(label, menu)
    ]);
};
const cClickPopupButton = (btnType, selector) => {
    const popupSelector = selector ? selector : '[role="dialog"]';
    return NamedChain.asChain([
        NamedChain.direct(NamedChain.inputName(), cWaitForVisible('waiting for: ' + popupSelector, popupSelector), 'popup'),
        NamedChain.direct('popup', Chain.binder((container) => UiFinder.findIn(container, getThemeSelectors()[btnType])), 'button'),
        NamedChain.direct('button', Mouse.cClick, '_'),
        NamedChain.outputInput
    ]);
};
const cCloseDialog = (selector) => cClickPopupButton('dialogCloseSelector', selector);
const cSubmitDialog = (selector) => cClickPopupButton('dialogSubmitSelector', selector);
export const UiChains = {
    cClickOnToolbar,
    cClickOnMenu,
    cClickOnUi,
    // Popups need to be visible.
    cWaitForPopup,
    // UI does not need to be visible
    cWaitForUi,
    // General state predicate
    cWaitForState,
    cCloseDialog,
    cSubmitDialog,
    cTriggerContextMenu
};
//# sourceMappingURL=UiChains.js.map
import { Assertions, Chain, Mouse, Step, UiFinder } from '@ephox/agar';
import { Arr, Fun } from '@ephox/katamari';
import { SugarElement, SugarShadowDom, Visibility } from '@ephox/sugar';
import * as TinyUiActions from '../bdd/TinyUiActions';
import { getThemeSelectors } from '../ThemeSelectors';
export const TinyUi = (editor) => {
    const uiRoot = SugarShadowDom.getContentContainer(SugarShadowDom.getRootNode(SugarElement.fromDom(editor.getElement())));
    const editorRoot = SugarElement.fromDom(editor.getBody());
    const clickOnToolbar = Fun.curry(TinyUiActions.clickOnToolbar, editor);
    const clickOnMenu = Fun.curry(TinyUiActions.clickOnMenu, editor);
    const clickOnUi = Fun.curry(TinyUiActions.clickOnUi, editor);
    const submitDialog = Fun.curry(TinyUiActions.submitDialog, editor);
    const pWaitForUi = Fun.curry(TinyUiActions.pWaitForUi, editor);
    const pWaitForPopup = Fun.curry(TinyUiActions.pWaitForPopup, editor);
    const cUiRoot = Chain.inject(uiRoot);
    const cEditorRoot = Chain.inject(editorRoot);
    const cFindIn = (cRoot, selector) => {
        return Chain.fromChains([
            cRoot,
            UiFinder.cFindIn(selector)
        ]);
    };
    const sClickOnToolbar = (label, selector) => Step.label(label, Step.sync(() => {
        TinyUiActions.clickOnToolbar(editor, selector);
    }));
    const sClickOnMenu = (label, selector) => Step.label(label, Step.sync(() => {
        TinyUiActions.clickOnMenu(editor, selector);
    }));
    const sClickOnUi = (label, selector) => Step.label(label, Step.sync(() => {
        TinyUiActions.clickOnUi(editor, selector);
    }));
    const sWaitForUi = (label, selector) => {
        return Chain.asStep({}, [
            cWaitForUi(label, selector)
        ]);
    };
    const sWaitForPopup = (label, selector) => {
        return Chain.asStep({}, [
            cWaitForPopup(label, selector)
        ]);
    };
    const cWaitForState = (hasState) => {
        return (label, selector) => {
            return Chain.fromChainsWith(uiRoot, [
                UiFinder.cWaitForState(label, selector, hasState)
            ]);
        };
    };
    const cWaitForPopup = (label, selector) => {
        return cWaitForState(Visibility.isVisible)(label, selector);
    };
    const cWaitForUi = (label, selector) => {
        return cWaitForState(Fun.always)(label, selector);
    };
    const cTriggerContextMenu = (label, target, menu) => {
        return Chain.fromChains([
            cFindIn(cEditorRoot, target),
            Mouse.cContextMenu,
            // Ignores input
            cWaitForPopup(label, menu)
        ]);
    };
    const getDialogByElement = (element) => {
        return Arr.find(editor.windowManager.getWindows(), (win) => {
            return element.dom.id === win._id;
        });
    };
    const cAssertDialogContents = (data) => {
        return Chain.async((element, next, die) => {
            getDialogByElement(element).fold(() => die('Can not find dialog'), (win) => {
                Assertions.assertEq('asserting dialog contents', data, win.toJSON());
                next(element);
            });
        });
    };
    const cFillDialogWith = (data) => {
        return Chain.async((element, next, die) => {
            getDialogByElement(element).fold(() => die('Can not find dialog'), (win) => {
                win.fromJSON({ ...win.toJSON(), ...data });
                next(element);
            });
        });
    };
    const sFillDialogWith = (data, selector) => {
        return Chain.asStep({}, [
            cFindIn(cUiRoot, selector),
            cFillDialogWith(data)
        ]);
    };
    const cSubmitDialog = () => {
        return Chain.fromChains([
            Chain.binder((container) => UiFinder.findIn(container, getThemeSelectors().dialogSubmitSelector)),
            Mouse.cClick
        ]);
    };
    const sSubmitDialog = (selector) => {
        return Chain.asStep({}, [
            cFindIn(cUiRoot, selector),
            cSubmitDialog()
        ]);
    };
    return {
        clickOnToolbar,
        clickOnMenu,
        clickOnUi,
        submitDialog,
        pWaitForUi,
        pWaitForPopup,
        sClickOnToolbar,
        sClickOnMenu,
        sClickOnUi,
        // Popups need to be visible.
        cWaitForPopup,
        // UI does not need to be visible
        cWaitForUi,
        // General state predicate
        cWaitForState,
        cFillDialogWith,
        sFillDialogWith,
        cSubmitDialog,
        sSubmitDialog,
        cAssertDialogContents,
        cTriggerContextMenu,
        sWaitForUi,
        sWaitForPopup
    };
};
//# sourceMappingURL=TinyUi.js.map
import { Eq } from '@ephox/dispute';
import * as Fun from './Fun';
import { Optional } from './Optional';
// There are many variations of Object iteration that are faster than the 'for-in' style:
// http://jsperf.com/object-keys-iteration/107
//
// Use the native keys if it is available (IE9+), otherwise fall back to manually filtering
export const keys = Object.keys;
// eslint-disable-next-line @typescript-eslint/unbound-method
export const hasOwnProperty = Object.hasOwnProperty;
export const each = (obj, f) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
        const i = props[k];
        const x = obj[i];
        f(x, i);
    }
};
export const map = (obj, f) => {
    return tupleMap(obj, (x, i) => ({
        k: i,
        v: f(x, i)
    }));
};
export const tupleMap = (obj, f) => {
    const r = {};
    each(obj, (x, i) => {
        const tuple = f(x, i);
        r[tuple.k] = tuple.v;
    });
    return r;
};
const objAcc = (r) => (x, i) => {
    r[i] = x;
};
const internalFilter = (obj, pred, onTrue, onFalse) => {
    each(obj, (x, i) => {
        (pred(x, i) ? onTrue : onFalse)(x, i);
    });
};
export const bifilter = (obj, pred) => {
    const t = {};
    const f = {};
    internalFilter(obj, pred, objAcc(t), objAcc(f));
    return { t, f };
};
export const filter = (obj, pred) => {
    const t = {};
    internalFilter(obj, pred, objAcc(t), Fun.noop);
    return t;
};
export const mapToArray = (obj, f) => {
    const r = [];
    each(obj, (value, name) => {
        r.push(f(value, name));
    });
    return r;
};
export const find = (obj, pred) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
        const i = props[k];
        const x = obj[i];
        if (pred(x, i, obj)) {
            return Optional.some(x);
        }
    }
    return Optional.none();
};
export const values = (obj) => {
    return mapToArray(obj, Fun.identity);
};
export const size = (obj) => {
    return keys(obj).length;
};
export const get = (obj, key) => {
    return has(obj, key) ? Optional.from(obj[key]) : Optional.none();
};
export const has = (obj, key) => hasOwnProperty.call(obj, key);
export const hasNonNullableKey = (obj, key) => has(obj, key) && obj[key] !== undefined && obj[key] !== null;
export const isEmpty = (r) => {
    for (const x in r) {
        if (hasOwnProperty.call(r, x)) {
            return false;
        }
    }
    return true;
};
export const equal = (a1, a2, eq = Eq.eqAny) => Eq.eqRecord(eq).eq(a1, a2);
//# sourceMappingURL=Obj.js.map
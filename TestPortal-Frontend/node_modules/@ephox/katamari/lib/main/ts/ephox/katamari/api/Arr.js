import { Eq } from '@ephox/dispute';
import * as Fun from './Fun';
import { Optional } from './Optional';
import * as Type from './Type';
/* eslint-disable @typescript-eslint/unbound-method */
const nativeSlice = Array.prototype.slice;
const nativeIndexOf = Array.prototype.indexOf;
const nativePush = Array.prototype.push;
/* eslint-enable */
const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
export const indexOf = (xs, x) => {
    // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
    const r = rawIndexOf(xs, x);
    return r === -1 ? Optional.none() : Optional.some(r);
};
export const contains = (xs, x) => rawIndexOf(xs, x) > -1;
export const exists = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
            return true;
        }
    }
    return false;
};
export const range = (num, f) => {
    const r = [];
    for (let i = 0; i < num; i++) {
        r.push(f(i));
    }
    return r;
};
// It's a total micro optimisation, but these do make some difference.
// Particularly for browsers other than Chrome.
// - length caching
// http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69
// - not using push
// http://jsperf.com/array-direct-assignment-vs-push/2
export const chunk = (array, size) => {
    const r = [];
    for (let i = 0; i < array.length; i += size) {
        const s = nativeSlice.call(array, i, i + size);
        r.push(s);
    }
    return r;
};
export const map = (xs, f) => {
    // pre-allocating array size when it's guaranteed to be known
    // http://jsperf.com/push-allocated-vs-dynamic/22
    const len = xs.length;
    const r = new Array(len);
    for (let i = 0; i < len; i++) {
        const x = xs[i];
        r[i] = f(x, i);
    }
    return r;
};
// Unwound implementing other functions in terms of each.
// The code size is roughly the same, and it should allow for better optimisation.
// const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
export const each = (xs, f) => {
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        f(x, i);
    }
};
export const eachr = (xs, f) => {
    for (let i = xs.length - 1; i >= 0; i--) {
        const x = xs[i];
        f(x, i);
    }
};
export const partition = (xs, pred) => {
    const pass = [];
    const fail = [];
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        const arr = pred(x, i) ? pass : fail;
        arr.push(x);
    }
    return { pass, fail };
};
export const filter = (xs, pred) => {
    const r = [];
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
            r.push(x);
        }
    }
    return r;
};
/*
 * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.
 *
 * f is a function that derives a value from an element - e.g. true or false, or a string.
 * Elements are like if this function generates the same value for them (according to ===).
 *
 *
 * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.
 *  For a good explanation, see the group function (which is a special case of groupBy)
 *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group
 */
export const groupBy = (xs, f) => {
    if (xs.length === 0) {
        return [];
    }
    else {
        let wasType = f(xs[0]); // initial case for matching
        const r = [];
        let group = [];
        for (let i = 0, len = xs.length; i < len; i++) {
            const x = xs[i];
            const type = f(x);
            if (type !== wasType) {
                r.push(group);
                group = [];
            }
            wasType = type;
            group.push(x);
        }
        if (group.length !== 0) {
            r.push(group);
        }
        return r;
    }
};
export const foldr = (xs, f, acc) => {
    eachr(xs, (x, i) => {
        acc = f(acc, x, i);
    });
    return acc;
};
export const foldl = (xs, f, acc) => {
    each(xs, (x, i) => {
        acc = f(acc, x, i);
    });
    return acc;
};
export const findUntil = (xs, pred, until) => {
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
            return Optional.some(x);
        }
        else if (until(x, i)) {
            break;
        }
    }
    return Optional.none();
};
export const find = (xs, pred) => {
    return findUntil(xs, pred, Fun.never);
};
export const findIndex = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
            return Optional.some(i);
        }
    }
    return Optional.none();
};
export const flatten = (xs) => {
    // Note, this is possible because push supports multiple arguments:
    // http://jsperf.com/concat-push/6
    // Note that in the past, concat() would silently work (very slowly) for array-like objects.
    // With this change it will throw an error.
    const r = [];
    for (let i = 0, len = xs.length; i < len; ++i) {
        // Ensure that each value is an array itself
        if (!Type.isArray(xs[i])) {
            throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
    }
    return r;
};
export const bind = (xs, f) => flatten(map(xs, f));
export const forall = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; ++i) {
        const x = xs[i];
        if (pred(x, i) !== true) {
            return false;
        }
    }
    return true;
};
export const equal = (a1, a2, eq = Eq.eqAny) => Eq.eqArray(eq).eq(a1, a2);
export const reverse = (xs) => {
    const r = nativeSlice.call(xs, 0);
    r.reverse();
    return r;
};
export const difference = (a1, a2) => filter(a1, (x) => !contains(a2, x));
export const mapToObject = (xs, f) => {
    const r = {};
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        r[String(x)] = f(x, i);
    }
    return r;
};
export const pure = (x) => [x];
export const sort = (xs, comparator) => {
    const copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
};
export const get = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
export const head = (xs) => get(xs, 0);
export const last = (xs) => get(xs, xs.length - 1);
export const from = Type.isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);
export const findMap = (arr, f) => {
    for (let i = 0; i < arr.length; i++) {
        const r = f(arr[i], i);
        if (r.isSome()) {
            return r;
        }
    }
    return Optional.none();
};
export const unique = (xs, comparator) => {
    const r = [];
    const isDuplicated = Type.isFunction(comparator) ?
        (x) => exists(r, (i) => comparator(i, x)) :
        (x) => contains(r, x);
    for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (!isDuplicated(x)) {
            r.push(x);
        }
    }
    return r;
};
//# sourceMappingURL=Arr.js.map
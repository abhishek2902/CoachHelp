import * as Fun from './Fun';
import { Optional } from './Optional';
import * as Type from './Type';
// --- Identities ---
/**
 Just a small optimisation - all nothing objects are identical, why not make
 them point to the same object?
*/
const singletonNothing = { tag: 0 /* Tag.Nothing */ };
/**
 Create a new Maybe<T> that **does not** contain a value. T can be any type
 (and defaults to the literal any type) because we don't actually have a T.
*/
export const nothing = () => singletonNothing;
/**
 Creates a new Maybe<T> that **does** contain a value.
*/
export const just = (value) => ({
    tag: 1 /* Tag.Just */,
    value
});
/**
 Perform a transform on a Maybe type. Similar to the fold method on a number
 of ADTs in the TinyMCE codebase, you pass two functions into this - if `self`
 **does not** contain a value then `onNothing` will be called (with no
 argument) but if `self` **does** contain a value then `onJust` will be
 called (with the value as its argument).

 For the FP enthusiasts in the room, this function:
 1. Could be used to implement all of the functions below (although it isn't)
 2. Forms a catamorphism
*/
export const fold = (onNothing, onJust) => (self) => {
    switch (self.tag) {
        case 0 /* Tag.Nothing */:
            return onNothing();
        case 1 /* Tag.Just */:
            return onJust(self.value);
    }
};
/**
 Determine if this Maybe object **does not** contain a value.
*/
export const isNothing = (self) => self.tag === 0 /* Tag.Nothing */;
/**
 Determine if this Maybe object contains a value. If this function returns
 true, you can access the value using `.value` on the object directly.
*/
export const isJust = (self) => self.tag === 1 /* Tag.Just */;
// --- Functor ---
/**
 Perform a transform on a Maybe object, **if** there is a value. If you
 provide a function to turn a T into a U, this is the function you use to turn
 a `Maybe<T>` into a `Maybe<U>`. If self **does** contain a value then the
 output will also contain a value (that value being the output of
 `mapper(self.value)`), and if self **does not** contain a value then
 neither will the output.
*/
export const map = (mapper) => (self) => isJust(self) ? just(mapper(self.value)) : nothing();
// --- Applicative ---
/**
 Perform a transform on two Maybe objects, **if** they both have values. If
 either of the objects does not contain a value, this will return an empty
 Maybe (nothing), but if all of the input objects do have a value then `fn`
 will be called (with all of those values as its arguments) and the output
 will be wrapped in another Maybe.
*/
export const lift2 = (a, b, fn) => {
    if (isJust(a) && isJust(b)) {
        return just(fn(a.value, b.value));
    }
    else {
        return nothing();
    }
};
/**
 Same as lift2, but with 3 maybe objects.
*/
export const lift3 = (a, b, c, fn) => {
    if (isJust(a) && isJust(b) && isJust(c)) {
        return just(fn(a.value, b.value, c.value));
    }
    else {
        return nothing();
    }
};
/**
 Same as lift2, but with 4 maybe objects.
*/
export const lift4 = (a, b, c, d, fn) => {
    if (isJust(a) && isJust(b) && isJust(c) && isJust(d)) {
        return just(fn(a.value, b.value, c.value, d.value));
    }
    else {
        return nothing();
    }
};
/**
 Same as lift2, but with 5 maybe objects.
*/
export const lift5 = (a, b, c, d, e, fn) => {
    if (isJust(a) && isJust(b) && isJust(c) && isJust(d) && isJust(e)) {
        return just(fn(a.value, b.value, c.value, d.value, e.value));
    }
    else {
        return nothing();
    }
};
// --- Monad ---
/**
 Un-nests a Maybe type. Conversion is as follows:
 Nothing ==> Nothing
 Just(Nothing) ==> Nothing
 Just(Just(T)) ==> Just(T)

 You shouldn't often end up with nested Maybe types to need this function, but
 if you do it's here.
*/
export const flatten = (self) => isJust(self) ? self.value : nothing();
/**
 Perform a transform on a Maybe object, **if** there is a value. Unlike the
 map function earlier in the piece, here the transform itself also returns a
 Maybe. Think of this like a combination of `map` and `flatten` at the same
 time.
*/
export const bind = (binder) => (self) => isJust(self) ? binder(self.value) : nothing();
// --- Traversable ---
/**
 For a given predicate, this function finds out if there **exists** a value
 inside this Maybe object that meets the predicate. In practice, this means
 that for empty objects it returns false (as no predicate-meeting object
 exists).
*/
export const exists = (predicate) => (self) => isJust(self) && predicate(self.value);
/**
 For a given predicate, this function finds out if **all** the values inside
 this maybe object meet the predicate. In practice, this means that for empty
 objects it returns true (as all 0 objects do meet the predicate).
*/
export const forall = (predicate) => (self) => isNothing(self) || predicate(self.value);
/**
 For a given predicate, create a new Maybe object that will retain all the
 values inside the old Maybe object that meet the predicate. In practice, the
 Maybe object contains either 0 or 1 objects, and the output will keep the
 (single) input object (if it exists) as long as it passes the predicate.
*/
export const filter = (predicate) => (self) => {
    if (isJust(self) && predicate(self.value)) {
        return just(self.value);
    }
    else {
        return nothing();
    }
};
// --- Getters ---
/**
 Get the value out of the inside of the Maybe object, using a default
 `replacement` value if the provided Maybe object does not contain a value.
*/
export const getOr = (replacement) => (self) => isJust(self) ? self.value : replacement;
/**
 Get the value out of the inside of the Maybe object, throwing an exception if
 the provided Maybe object does not contain a value.

 WARNING:
 1. You should only be using this function if you know that the Maybe object
 **is not** empty (otherwise you're throwing exceptions in production code,
 which is bad).
 2. If you know that the Maybe object is not empty, then TypeScript should
 also know that the Maybe object is not empty (comparison operations on `.tag`
 as well as the `isJust` method will both allow the compiler to infer that the
 object is not empty).
 3. If TypeScript knows that the Maybe object is not empty, it will let you
 just access `.value` directly, without needing this function + without
 risking an exception being thrown.

 Therefore, you should only be calling this function in environments where
 you're unable to completely type-check your code (IE: tests). In all other
 situations, **avoid this method**.
*/
export const getOrDie = (self) => {
    if (isNothing(self)) {
        throw new Error('Called getOrDie on Nothing');
    }
    return self.value;
};
/**
 Get the value out of the inside of the Maybe object, using a default
 `replacement` value if the provided Maybe object does not contain a value.
 Unlike `getOr`, in this method the `replacement` value is "thunked" - that is
 to say that you don't pass a value to `getOrThunk`, you pass a function which
 (if called) will **return** the `value` you want to use.
*/
export const getOrThunk = (thunk) => (self) => isJust(self) ? self.value : thunk();
// --- Comparators ---
/**
 **Is** the value stored inside this Maybe object equal to `other`?
*/
export const is = (other, comparator = Fun.tripleEquals) => (self) => isJust(self) && comparator(self.value, other);
/**
 Are these two Maybe objects equal? Equality here means either they're both
 `Just` (and the values are equal under the comparator) or they're both
 `Nothing`.
*/
export const equals = (lhs, rhs, comparator = Fun.tripleEquals) => {
    if (isJust(lhs) && isJust(rhs)) {
        return comparator(lhs.value, rhs.value);
    }
    else {
        return lhs.tag === rhs.tag;
    }
};
// --- Interop with null and undefined ---
/**
 Creates a Maybe value from a nullable (or undefined-able) input. Null, or
 undefined, is converted to Nothing, and anything else is converted to Just.
*/
export const from = (input) => {
    if (Type.isNonNullable(input)) {
        return just(input);
    }
    else {
        return nothing();
    }
};
/**
 Converts a Maybe to a nullable type.
*/
export const getOrNull = getOr(null);
/**
 Converts a Maybe to an undefined-able type.
*/
export const getOrUndefined = getOr(undefined);
/**
 This is just like `bind`, but instead of the `binder` returning a `Maybe<U>`,
 it returns a nullable (or undefined-able) `U`. This is just a little bit of
 sugar so that if you have a function which is designed to work with nullable
 (or undefined-able) return types, you don't need to wrap it to use it with
 bind.
*/
export const bindNullable = (binder) => (self) => isJust(self) ? from(binder(self.value)) : nothing();
// --- Interop with other Katamari modules ---
/**
 Convert a Maybe object to an array. Empty Maybe - empty array. Non-empty Maybe - non-empty array.
*/
export const toArr = (self) => isJust(self) ? [self.value] : [];
/**
 Convert a Maybe object to an Optional object. Just === Some, and Nothing === None
*/
export const toOptional = (self) => isJust(self) ? Optional.some(self.value) : Optional.none();
/**
 Convert an Optional object to a Maybe object. Some === Just, and None === Nothing.
*/
export const fromOptional = (other) => other.fold(nothing, just);
/**
 This is just like `bind`, but instead of the `binder` returning a `Maybe<U>`,
 it returns an `Optional<U>`. This is just a little bit of sugar so that if
 you have a function which is designed to work with `Optional` return types,
 you don't need to wrap it to use it with bind.
*/
export const bindO = (binder) => (self) => isJust(self) ? fromOptional(binder(self.value)) : nothing();
//# sourceMappingURL=Maybes.js.map
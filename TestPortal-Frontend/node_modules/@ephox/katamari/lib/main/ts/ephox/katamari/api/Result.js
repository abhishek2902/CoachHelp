import * as Fun from './Fun';
import { Optional } from './Optional';
/**
 * Creates a new `Result<T, E>` that **does** contain a value.
 */
const value = (value) => {
    const applyHelper = (fn) => fn(value);
    const constHelper = Fun.constant(value);
    const outputHelper = () => output;
    const output = {
        // Debug info
        tag: true,
        inner: value,
        // Actual Result methods
        fold: (_onError, onValue) => onValue(value),
        isValue: Fun.always,
        isError: Fun.never,
        map: (mapper) => Result.value(mapper(value)),
        mapError: outputHelper,
        bind: applyHelper,
        exists: applyHelper,
        forall: applyHelper,
        getOr: constHelper,
        or: outputHelper,
        getOrThunk: constHelper,
        orThunk: outputHelper,
        getOrDie: constHelper,
        each: (fn) => {
            // Can't write the function inline because we don't want to return something by mistake
            fn(value);
        },
        toOptional: () => Optional.some(value),
    };
    return output;
};
/**
 * Creates a new `Result<T, E>` that **does not** contain a value, and therefore
 * contains an error.
 */
const error = (error) => {
    const outputHelper = () => output;
    const output = {
        // Debug info
        tag: false,
        inner: error,
        // Actual Result methods
        fold: (onError, _onValue) => onError(error),
        isValue: Fun.never,
        isError: Fun.always,
        map: outputHelper,
        mapError: (mapper) => Result.error(mapper(error)),
        bind: outputHelper,
        exists: Fun.never,
        forall: Fun.always,
        getOr: Fun.identity,
        or: Fun.identity,
        getOrThunk: Fun.apply,
        orThunk: Fun.apply,
        getOrDie: Fun.die(String(error)),
        each: Fun.noop,
        toOptional: Optional.none,
    };
    return output;
};
/**
 * Creates a new `Result<T, E>` from an `Optional<T>` and an `E`. If the
 * `Optional` contains a value, so will the outputted `Result`. If it does not,
 * the outputted `Result` will contain an error (and that error will be the
 * error passed in).
 */
const fromOption = (optional, err) => optional.fold(() => error(err), value);
export const Result = {
    value,
    error,
    fromOption
};
//# sourceMappingURL=Result.js.map
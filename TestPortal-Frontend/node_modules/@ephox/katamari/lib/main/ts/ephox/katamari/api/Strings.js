import * as StrAppend from '../str/StrAppend';
import { Optional } from './Optional';
import * as Type from './Type';
const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
/** Given a string and object, perform template-replacements on the string, as specified by the object.
 * Any template fields of the form ${name} are replaced by the string or number specified as obj["name"]
 * Based on Douglas Crockford's 'supplant' method for template-replace of strings. Uses different template format.
 */
export const supplant = (str, obj) => {
    const isStringOrNumber = (a) => {
        const t = typeof a;
        return t === 'string' || t === 'number';
    };
    return str.replace(/\$\{([^{}]*)\}/g, (fullMatch, key) => {
        const value = obj[key];
        return isStringOrNumber(value) ? value.toString() : fullMatch;
    });
};
export const removeLeading = (str, prefix) => {
    return startsWith(str, prefix) ? StrAppend.removeFromStart(str, prefix.length) : str;
};
export const removeTrailing = (str, suffix) => {
    return endsWith(str, suffix) ? StrAppend.removeFromEnd(str, suffix.length) : str;
};
export const ensureLeading = (str, prefix) => {
    return startsWith(str, prefix) ? str : StrAppend.addToStart(str, prefix);
};
export const ensureTrailing = (str, suffix) => {
    return endsWith(str, suffix) ? str : StrAppend.addToEnd(str, suffix);
};
export const contains = (str, substr, start = 0, end) => {
    const idx = str.indexOf(substr, start);
    if (idx !== -1) {
        return Type.isUndefined(end) ? true : idx + substr.length <= end;
    }
    else {
        return false;
    }
};
export const capitalize = (str) => {
    return str === '' ? '' : str.charAt(0).toUpperCase() + str.substring(1);
};
/** Does 'str' start with 'prefix'?
 *  Note: all strings start with the empty string.
 *        More formally, for all strings x, startsWith(x, "").
 *        This is so that for all strings x and y, startsWith(y + x, y)
 */
export const startsWith = (str, prefix) => {
    return checkRange(str, prefix, 0);
};
/** Does 'str' end with 'suffix'?
 *  Note: all strings end with the empty string.
 *        More formally, for all strings x, endsWith(x, "").
 *        This is so that for all strings x and y, endsWith(x + y, y)
 */
export const endsWith = (str, suffix) => {
    return checkRange(str, suffix, str.length - suffix.length);
};
const blank = (r) => (s) => s.replace(r, '');
/** removes all leading and trailing spaces */
export const trim = blank(/^\s+|\s+$/g);
export const lTrim = blank(/^\s+/g);
export const rTrim = blank(/\s+$/g);
export const isNotEmpty = (s) => s.length > 0;
export const isEmpty = (s) => !isNotEmpty(s);
export const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);
export const fromCodePoint = String.fromCodePoint;
export const toInt = (value, radix = 10) => {
    const num = parseInt(value, radix);
    return isNaN(num) ? Optional.none() : Optional.some(num);
};
export const toFloat = (value) => {
    const num = parseFloat(value);
    return isNaN(num) ? Optional.none() : Optional.some(num);
};
//# sourceMappingURL=Strings.js.map
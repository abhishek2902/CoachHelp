const getPrototypeOf = Object.getPrototypeOf;
const hasProto = (v, constructor, predicate) => {
    var _a;
    if (predicate(v, constructor.prototype)) {
        return true;
    }
    else {
        // String-based fallback time
        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    }
};
const typeOf = (x) => {
    const t = typeof x;
    if (x === null) {
        return 'null';
    }
    else if (t === 'object' && Array.isArray(x)) {
        return 'array';
    }
    else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
        return 'string';
    }
    else {
        return t;
    }
};
const isType = (type) => (value) => typeOf(value) === type;
const isSimpleType = (type) => (value) => typeof value === type;
const eq = (t) => (a) => t === a;
export const is = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf(o) === proto);
export const isString = isType('string');
export const isObject = isType('object');
export const isPlainObject = (value) => is(value, Object);
export const isArray = isType('array');
export const isNull = eq(null);
export const isBoolean = isSimpleType('boolean');
export const isUndefined = eq(undefined);
export const isNullable = (a) => a === null || a === undefined;
export const isNonNullable = (a) => !isNullable(a);
export const isFunction = isSimpleType('function');
export const isNumber = isSimpleType('number');
export const isArrayOf = (value, pred) => {
    if (isArray(value)) {
        for (let i = 0, len = value.length; i < len; ++i) {
            if (!(pred(value[i]))) {
                return false;
            }
        }
        return true;
    }
    return false;
};
//# sourceMappingURL=Type.js.map
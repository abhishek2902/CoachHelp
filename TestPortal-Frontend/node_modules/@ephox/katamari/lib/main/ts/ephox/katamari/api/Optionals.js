import * as Arr from './Arr';
import * as Fun from './Fun';
import { Optional } from './Optional';
/**
 * **Is** the value stored inside this Optional object equal to `rhs`?
 */
export const is = (lhs, rhs, comparator = Fun.tripleEquals) => lhs.exists((left) => comparator(left, rhs));
/**
 * Are these two Optional objects equal? Equality here means either they're both
 * `Some` (and the values are equal under the comparator) or they're both `None`.
 */
export const equals = (lhs, rhs, comparator = Fun.tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
export const cat = (arr) => {
    const r = [];
    const push = (x) => {
        r.push(x);
    };
    for (let i = 0; i < arr.length; i++) {
        arr[i].each(push);
    }
    return r;
};
export const sequence = (arr) => {
    const r = [];
    for (let i = 0; i < arr.length; i++) {
        const x = arr[i];
        if (x.isSome()) {
            r.push(x.getOrDie());
        }
        else {
            return Optional.none();
        }
    }
    return Optional.some(r);
};
/** @deprecated Use Arr.findMap instead. */
export const findMap = Arr.findMap;
/** Map each element of an array to an Optional and collect the results.
 *  If all results are "some", return Optional.some of the results.
 *  If any result is "none", return Optional.none
 */
export const traverse = (arr, f) => sequence(Arr.map(arr, f));
/*
Notes on the lift functions:
- We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
- The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
- && is used instead of a loop for simplicity and performance.
*/
export const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
export const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
export const lift4 = (oa, ob, oc, od, f) => oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie())) : Optional.none();
export const lift5 = (oa, ob, oc, od, oe, f) => oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() && oe.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie(), oe.getOrDie())) : Optional.none();
export const mapFrom = (a, f) => (a !== undefined && a !== null) ? Optional.some(f(a)) : Optional.none();
export const bindFrom = (a, f) => (a !== undefined && a !== null) ? f(a) : Optional.none();
export const flatten = (oot) => oot.bind(Fun.identity);
// This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
export const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
//# sourceMappingURL=Optionals.js.map
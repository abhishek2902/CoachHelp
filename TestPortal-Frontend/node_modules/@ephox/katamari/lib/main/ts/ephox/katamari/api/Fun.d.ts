declare const noop: (...args: any[]) => void;
declare const noarg: <T>(f: () => T) => (...args: any[]) => void;
/** Compose a unary function with an n-ary function */
declare const compose: <T extends any[], U, V>(fa: (v: U) => V, fb: (...x: T) => U) => (...x: T) => V;
/** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */
declare const compose1: <A, B, C>(fbc: (b: B) => C, fab: (a: A) => B) => (a: A) => C;
declare const constant: <T>(value: T) => () => T;
declare const identity: <T = any>(x: T) => T;
declare const tripleEquals: <T>(a: T, b: T) => boolean;
declare function curry<REST extends any[], OUT>(fn: (...restArgs: REST) => OUT): (...restArgs: REST) => OUT;
declare function curry<A, REST extends any[], OUT>(fn: (a: A, ...restArgs: REST) => OUT, a: A): (...restArgs: REST) => OUT;
declare function curry<A, B, REST extends any[], OUT>(fn: (a: A, b: B, ...restArgs: REST) => OUT, a: A, b: B): (...restArgs: REST) => OUT;
declare function curry<A, B, C, REST extends any[], OUT>(fn: (a: A, b: B, c: C, ...restArgs: REST) => OUT, a: A, b: B, c: C): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, F, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, f: F, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E, f: F): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, F, G, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E, f: F, g: G): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, F, G, H, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, F, G, H, I, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I): (...restArgs: REST) => OUT;
declare function curry<A, B, C, D, E, F, G, H, I, J, REST extends any[], OUT>(fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, ...restArgs: REST) => OUT, a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J): (...restArgs: REST) => OUT;
declare const not: <T>(f: (t: T) => boolean) => (t: T) => boolean;
declare const die: (msg: string) => () => never;
declare const apply: <T>(f: () => T) => T;
declare const call: (f: () => any) => void;
declare const never: (...args: any[]) => false;
declare const always: (...args: any[]) => true;
declare const weaken: <A, B extends A>(b: B) => A;
type Fun<X, Y> = (x: X) => Y;
declare const pipe: {
    <A, B>(a: A, ab: Fun<A, B>): B;
    <A, B, C>(a: A, ab: Fun<A, B>, bc: Fun<B, C>): C;
    <A, B, C, D>(a: A, ab: Fun<A, B>, bc: Fun<B, C>, cd: Fun<C, D>): D;
    <A, B, C, D, E>(a: A, ab: Fun<A, B>, bc: Fun<B, C>, cd: Fun<C, D>, de: Fun<D, E>): E;
    <A, B, C, D, E, F>(a: A, ab: Fun<A, B>, bc: Fun<B, C>, cd: Fun<C, D>, de: Fun<D, E>, ef: Fun<E, F>): F;
    <A, B, C, D, E, F, G>(a: A, ab: Fun<A, B>, bc: Fun<B, C>, cd: Fun<C, D>, de: Fun<D, E>, ef: Fun<E, F>, fg: Fun<F, G>): G;
    <A, B, C, D, E, F, G, H>(a: A, ab: Fun<A, B>, bc: Fun<B, C>, cd: Fun<C, D>, de: Fun<D, E>, ef: Fun<E, F>, fg: Fun<F, G>, gh: Fun<G, H>): H;
};
export { noop, noarg, compose, compose1, constant, identity, tripleEquals, curry, not, die, apply, call, never, always, weaken, pipe };
//# sourceMappingURL=Fun.d.ts.map
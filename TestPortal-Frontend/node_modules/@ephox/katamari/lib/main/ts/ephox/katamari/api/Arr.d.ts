import { Eq } from '@ephox/dispute';
import { Optional } from './Optional';
type ArrayMorphism<T, U> = (x: T, i: number) => U;
type ArrayGuardPredicate<T, U extends T> = (x: T, i: number) => x is U;
type ArrayPredicate<T> = ArrayMorphism<T, boolean>;
type Comparator<T> = (a: T, b: T) => number;
export declare const indexOf: <T = any>(xs: ArrayLike<T>, x: T) => Optional<number>;
export declare const contains: <T>(xs: ArrayLike<T>, x: T) => boolean;
export declare const exists: <T = any>(xs: ArrayLike<T>, pred: ArrayPredicate<T>) => boolean;
export declare const range: <T>(num: number, f: (a: number) => T) => T[];
export declare const chunk: <T>(array: ArrayLike<T>, size: number) => T[][];
export declare const map: <T = any, U = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, U>) => U[];
export declare const each: <T = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, void>) => void;
export declare const eachr: <T>(xs: ArrayLike<T>, f: ArrayMorphism<T, void>) => void;
export declare const partition: <T = any>(xs: ArrayLike<T>, pred: ArrayPredicate<T>) => {
    pass: T[];
    fail: T[];
};
export declare const filter: {
    <T, U extends T>(xs: ArrayLike<T>, pred: ArrayGuardPredicate<T, U>): U[];
    <T>(xs: ArrayLike<T>, pred: ArrayPredicate<T>): T[];
};
export declare const groupBy: <T>(xs: ArrayLike<T>, f: (a: T) => any) => T[][];
export declare const foldr: <T, U>(xs: ArrayLike<T>, f: (acc: U, x: T, i: number) => U, acc: U) => U;
export declare const foldl: <T = any, U = any>(xs: ArrayLike<T>, f: (acc: U, x: T, i: number) => U, acc: U) => U;
export declare const findUntil: {
    <T, U extends T>(xs: ArrayLike<T>, pred: ArrayGuardPredicate<T, U>, until: ArrayPredicate<T>): Optional<U>;
    <T = any>(xs: ArrayLike<T>, pred: ArrayPredicate<T>, until: ArrayPredicate<T>): Optional<T>;
};
export declare const find: {
    <T, U extends T>(xs: ArrayLike<T>, pred: ArrayGuardPredicate<T, U>): Optional<U>;
    <T = any>(xs: ArrayLike<T>, pred: ArrayPredicate<T>): Optional<T>;
};
export declare const findIndex: <T>(xs: ArrayLike<T>, pred: ArrayPredicate<T>) => Optional<number>;
export declare const flatten: <T>(xs: ArrayLike<T[]>) => T[];
export declare const bind: <T = any, U = any>(xs: ArrayLike<T>, f: ArrayMorphism<T, U[]>) => U[];
export declare const forall: <T>(xs: ArrayLike<T>, pred: ArrayPredicate<T>) => boolean;
export declare const equal: <T>(a1: ArrayLike<T>, a2: ArrayLike<T>, eq?: Eq.Eq<T>) => boolean;
export declare const reverse: <T>(xs: ArrayLike<T>) => T[];
export declare const difference: <T>(a1: ArrayLike<T>, a2: ArrayLike<T>) => T[];
export declare const mapToObject: {
    <T extends string, U>(xs: ArrayLike<T>, f: (x: T, i: number) => U): Record<T, U>;
    <T, R extends Record<string, any>>(xs: ArrayLike<T>, f: (x: T, i: number) => R[keyof R]): R;
};
export declare const pure: <T>(x: T) => T[];
export declare const sort: <T>(xs: ArrayLike<T>, comparator?: Comparator<T> | undefined) => T[];
export declare const get: <T>(xs: ArrayLike<T>, i: number) => Optional<T>;
export declare const head: <T>(xs: ArrayLike<T>) => Optional<T>;
export declare const last: <T>(xs: ArrayLike<T>) => Optional<T>;
export declare const from: <T>(x: ArrayLike<T>) => T[];
export declare const findMap: <A, B>(arr: ArrayLike<A>, f: (a: A, index: number) => Optional<B>) => Optional<B>;
export declare const unique: <T>(xs: ArrayLike<T>, comparator?: ((a: T, b: T) => boolean) | undefined) => T[];
export {};
//# sourceMappingURL=Arr.d.ts.map
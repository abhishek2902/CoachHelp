import { Eq } from '@ephox/dispute';
import { Optional } from './Optional';
type ObjKeys<T extends {}> = Extract<keyof T, string>;
type ObjCallback<T extends {}> = (value: T[keyof T], key: ObjKeys<T>) => void;
type ObjMorphism<T extends {}, R> = (value: T[keyof T], key: ObjKeys<T>) => R;
type ObjGuardPredicate<T extends {}, U extends T[keyof T]> = (value: T[keyof T], key: ObjKeys<T>) => value is U;
type ObjPredicate<T extends {}> = (value: T[keyof T], key: ObjKeys<T>) => boolean;
export declare const keys: {
    (o: object): string[];
    (o: {}): string[];
};
export declare const hasOwnProperty: (v: PropertyKey) => boolean;
export declare const each: <T extends {}>(obj: T, f: ObjCallback<T>) => void;
export declare const map: <T extends {}, R>(obj: T, f: ObjMorphism<T, R>) => { [k in keyof T]: R; };
export declare const tupleMap: <R extends {}, T extends {}>(obj: T, f: ObjMorphism<T, {
    k: keyof R;
    v: R[keyof R];
}>) => R;
export declare const bifilter: <T extends {}>(obj: T, pred: ObjPredicate<T>) => {
    t: Record<string, T[keyof T]>;
    f: Record<string, T[keyof T]>;
};
export declare const filter: {
    <T extends {}, U extends T[keyof T]>(obj: T, pred: ObjGuardPredicate<T, U>): Record<string, U>;
    <T extends {}>(obj: T, pred: ObjPredicate<T>): Record<string, T[keyof T]>;
};
export declare const mapToArray: <T extends {}, R>(obj: T, f: ObjMorphism<T, R>) => R[];
export declare const find: <T extends {}>(obj: T, pred: (value: T[keyof T], key: Extract<keyof T, string>, obj: T) => boolean) => Optional<T[keyof T]>;
export declare const values: <T extends {}>(obj: T) => T[keyof T][];
export declare const size: (obj: {}) => number;
export declare const get: <T extends {}, K extends keyof T>(obj: T, key: K) => Optional<NonNullable<T[K]>>;
export declare const has: <T extends {}, K extends keyof T>(obj: T, key: K) => boolean;
export declare const hasNonNullableKey: <T extends {}, K extends keyof T>(obj: T, key: K) => obj is T & Record<K, NonNullable<T[K]>>;
export declare const isEmpty: (r: Record<any, any>) => boolean;
export declare const equal: <T>(a1: Record<string, T>, a2: Record<string, T>, eq?: Eq.Eq<T>) => boolean;
export {};
//# sourceMappingURL=Obj.d.ts.map
import * as Type from './Type';
// Run a function fn after rate ms. If another invocation occurs
// during the time it is waiting, update the arguments f will run
// with (but keep the current schedule)
export const adaptable = (fn, rate) => {
    let timer = null;
    let args = null;
    const cancel = () => {
        if (!Type.isNull(timer)) {
            clearTimeout(timer);
            timer = null;
            args = null;
        }
    };
    const throttle = (...newArgs) => {
        args = newArgs;
        if (Type.isNull(timer)) {
            timer = setTimeout(() => {
                const tempArgs = args;
                timer = null;
                args = null;
                fn.apply(null, tempArgs);
            }, rate);
        }
    };
    return {
        cancel,
        throttle
    };
};
// Run a function fn after rate ms. If another invocation occurs
// during the time it is waiting, ignore it completely.
export const first = (fn, rate) => {
    let timer = null;
    const cancel = () => {
        if (!Type.isNull(timer)) {
            clearTimeout(timer);
            timer = null;
        }
    };
    const throttle = (...args) => {
        if (Type.isNull(timer)) {
            timer = setTimeout(() => {
                timer = null;
                fn.apply(null, args);
            }, rate);
        }
    };
    return {
        cancel,
        throttle
    };
};
// Run a function fn after rate ms. If another invocation occurs
// during the time it is waiting, reschedule the function again
// with the new arguments.
export const last = (fn, rate) => {
    let timer = null;
    const cancel = () => {
        if (!Type.isNull(timer)) {
            clearTimeout(timer);
            timer = null;
        }
    };
    const throttle = (...args) => {
        cancel();
        timer = setTimeout(() => {
            timer = null;
            fn.apply(null, args);
        }, rate);
    };
    return {
        cancel,
        throttle
    };
};
//# sourceMappingURL=Throttler.js.map